<%# 

# Parameters
- optional: boolean
If true, only cloze-one-by-one mode if {{One by one}} field is not empty. 

# Components
components/clozeOneByOneButtons
components/ankingAddEventListener
components/shortcutMatcher

# Global Variables
- revealClozeShortcut: shortcut string
- revealClozeWordShortcut: shortcut string
- clozeHider: (elem) -> string
- clozeHints?: Array[string]

# Notes
- Removes `#qa` element `display` property.
- Exposes `toggleAllCloze` and `revealNextCloze` function

# How it works
|                .cloze                   |
| shown | .cloze-replacer | .cloze-hidden |

When hideAllCloze() is called, all childNodes of .cloze is moved into .cloze-hidden, 
and .cloze has two children: div.cloze-replacer that hides cloze with `clozeHider(div.cloze-hidden)`, 
div.cloze-hidden with original cloze content that is hidden with display:none.

When revealNextWord() is called, a word is selected from .cloze-hidden and is inserted before div.cloze-replacer
_%>
<%- include('src/components/autoflipBack.ejs') %>

<!-- CLOZE ONE BY ONE SCRIPT -->
<style>
  .cloze-replacer:hover {
    cursor: pointer;
  }
  .cloze-hidden {
    display: none;
  }
  .cloze-hint {
    color: #009400 !important;
  }
</style>

<script>
  (function() {
    var clozeOneByOneEnabled = true;
    <%_ if (optional === true) { _%>
      clozeOneByOneEnabled = document.getElementById("one-by-one").textContent !== "";
    <%_ } _%>

    if (!clozeOneByOneEnabled) {
      return
    }
    
    const revealCloze = function(cloze) {
      const clozeReplacer = cloze.getElementsByClassName("cloze-replacer")[0]
      const clozeHidden = cloze.getElementsByClassName("cloze-hidden")[0]
      if (!clozeReplacer || !clozeHidden) return;

      cloze.removeChild(clozeReplacer)
      cloze.removeChild(clozeHidden)
      for(const child of clozeHidden.childNodes) {
        cloze.appendChild(child)
      }
      rerunMathJax() // Is this still needed?
    }

    const revealClozeWord = function(cloze) {
      const clozeReplacer = cloze.getElementsByClassName("cloze-replacer")[0]
      const clozeHidden = cloze.getElementsByClassName("cloze-hidden")[0]
      if (!clozeReplacer || !clozeHidden) return;

      const range = new Range()
      range.setStart(clozeHidden, 0)
      let enable = true
      while(enable) {
        const found = setRangeEndToFirstSpace(range, clozeHidden)
        if (!found) {
          range.setEnd(clozeHidden, clozeHidden.childNodes.length)
        }
        const onlyWhitespace = /^\s*$/.test(range.toString())
        enable = found && onlyWhitespace

        const fragment = range.extractContents()
        cloze.insertBefore(fragment, clozeReplacer)
        clozeReplacer.innerHTML = clozeHider(clozeHidden)
        if (!found) {
          cloze.removeChild(clozeHidden)
          cloze.removeChild(clozeReplacer)
        }
      }
      rerunMathJax()
    }

    const clozeElOfClozeHidden = (cloze) => {
      while (!cloze.classList.contains("cloze")) {
        cloze = cloze.parentElement;
      }
      return cloze;
    }

    const revealNextClozeOf = (type) => {
      const nextHidden = document.querySelector(".cloze-hidden")
      if(!nextHidden) {
          return
      } 
      const cloze = clozeElOfClozeHidden(nextHidden);
      if (type === "word") {
          revealClozeWord(cloze)
      } else if (type === "cloze") {
          revealCloze(cloze)
      } else {
        console.error("Invalid type: " + type)
      }
    }

    window.revealNextCloze = function() {
      revealNextClozeOf(revealNextClozeMode)
    }

    /**
     * Call range.setEnd() to before first whitespace character in node.
     * Return `true` whitespace exists and setEnd() was called, otherwise `false`
     */
    const setRangeEndToFirstSpace = function(range, node) {
      if (node.nodeType === Node.TEXT_NODE) {
        let firstWhitespace = -1;
        for (const whitespace of [" ", "\n", "\t"]) {
          const index = text.indexOf(whitespace);
          if (index !== -1 && (firstWhitespace === -1 || index < firstWhitespace)) {
            firstWhitespace = index;
          }
        }
        if (firstWhitespace !== -1) {
          range.setEnd(node, firstWhitespace);
          return true;
        } else {
          return false;
        }
      } else {
        for (const child of node.childNodes) {
          if (setRangeEndToFirstSpace(range, child)) {
            return true;
          }
        }
        return false;
      }
    }

    const hideAllCloze = function(initial) {
      let clozes = document.getElementsByClassName("cloze")
      let count = 0 // hidden cloze count
      for (const cloze of clozes) {
        if (cloze.offsetWidth === 0) {
          continue
        }
        const clozeReplacer = document.createElement("span")
        const clozeHidden = document.createElement("span")
        clozeReplacer.classList.add("cloze-replacer")
        clozeHidden.classList.add("cloze-hidden")
        clozeReplacer.innerHTML = clozeHider(cloze)
        for(const child of cloze.childNodes) {
          clozeHidden.appendChild(child);
        }
        cloze.appendChild(clozeReplacer)
        cloze.appendChild(clozeHidden)

        if (window.clozeHints && window.clozeHints[count]) {
          clozeReplacer.classList.add("cloze-hint")
          clozeReplacer.innerHTML = window.clozeHints[count]
        }
        count += 1
        if (initial) {
          cloze.addEventListener("touchend", revealClozeClicked)
          cloze.addEventListener("click", revealClozeClicked)
        }
      }
    }

    window.toggleAllCloze = function() {
      let elems = document.querySelectorAll(".cloze-hidden")
      if(elems.length > 0) {
        for (const elem of elems) {
          const cloze = clozeElOfClozeHidden(elem)
          revealCloze(cloze)
        }
      } else {
        hideAllCloze(initial=false)
      }
    }

    const revealClozeClicked = function(ev) {
      let elem = ev.currentTarget
      if (!ev.altKey && (revealNextClozeMode !== "word")) {
        revealCloze(elem)
      } else {
        revealClozeWord(elem)
      }
      ev.stopPropagation()
      ev.preventDefault()
    }      

    const rerunMathJax = function() {
      // rerun mathjax on the document so that the cloze text gets formatted
      // ... for MathJax 2
      try {
          MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
      } catch {}
      // ... for MathJax 3     
      try {
          MathJax.typesetPromise()
      } catch {}
    }
    
    hideAllCloze(initial=true)

    let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)
    let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)
    let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)
    ankingAddEventListener("keydown", (ev) => {
      let next = isShowNextShortcut(ev)
      let word = isShowWordShortcut(ev)
      let all = isToggleAllShortcut(ev)
      if (next) {
        revealNextClozeOf("cloze")
      } else if (word) {
        revealNextClozeOf("word")
      } else if (all) {
        toggleAllCloze()
      } else {
        return;
      }
      ev.stopPropagation()
      ev.preventDefault()
    });
  })()
</script>