<%# 

# Parameters
- optional: boolean
If true, only cloze-one-by-one mode if {{One by one}} field is not empty. 

# Components
components/clozeOneByOneButtons
components/ankingAddEventListener
components/shortcutMatcher

# Global Variables
- revealClozeShortcut: shortcut string
- revealClozeWordShortcut: shortcut string
- clozeHider: (elem) -> string
- clozeHints?: Array[string]

# Notes
- Removes `#qa` element `display` property.
- Exposes `toggleAllCloze` and `revealNextCloze` function

# How it works
|                .cloze                   |
| shown | .cloze-replacer | .cloze-hidden |

When hideAllCloze() is called, all childNodes of .cloze is moved into .cloze-hidden, 
and .cloze has two children: div.cloze-replacer that hides cloze with `clozeHider(div.cloze-hidden)`, 
div.cloze-hidden with original cloze content that is hidden with display:none.

When revealNextWord() is called, a word is selected from .cloze-hidden and is inserted before div.cloze-replacer
_%>
<%- include('src/components/autoflipBack.ejs') %>

<!-- CLOZE ONE BY ONE SCRIPT -->
<style>
  .cloze-replacer:hover {
    cursor: pointer;
  }
  .cloze-hidden {
    display: none;
  }
  .cloze-hint {
    color: #009400 !important;
  }
</style>

<script>
  (function() {
    var clozeOneByOneEnabled = true;
    <%_ if (optional === true) { _%>
      clozeOneByOneEnabled = document.getElementById("one-by-one").textContent !== "";
    <%_ } _%>

    if (!clozeOneByOneEnabled) {
      return
    }
    
    const revealCloze = function(cloze) {
      const clozeReplacer = cloze.getElementsByClassName("cloze-replacer")[0]
      const clozeHidden = cloze.getElementsByClassName("cloze-hidden")[0]
      if (!clozeReplacer || !clozeHidden) return;

      cloze.removeChild(clozeReplacer)
      cloze.removeChild(clozeHidden)
      while (clozeHidden.childNodes.length > 0) {
        cloze.appendChild(clozeHidden.childNodes[0])
      }
    }

    const revealClozeWord = function(cloze) {
      const clozeReplacer = cloze.getElementsByClassName("cloze-replacer")[0]
      const clozeHidden = cloze.getElementsByClassName("cloze-hidden")[0]
      if (!clozeReplacer || !clozeHidden) return;

      let range = new Range()
      range.setStart(clozeHidden, 0)
      const whitespaces = setRangeEndToAfterLastSpace(range, clozeHidden);
      if (whitespaces) {
        const fragment = range.extractContents();
        cloze.insertBefore(fragment, clozeReplacer)
      }

      range = new Range()
      range.setStart(clozeHidden, 0)
      const found = setRangeEndToBeforeFirstSpace(range, clozeHidden)
      if (!found) {
        range.setEnd(clozeHidden, clozeHidden.childNodes.length)
      }
      const fragment = range.extractContents()
      cloze.insertBefore(fragment, clozeReplacer)
      if (found) {
        clozeReplacer.innerHTML = clozeHider(clozeHidden)
      } else {
        cloze.removeChild(clozeHidden)
        cloze.removeChild(clozeReplacer)
      }
    }

    const clozeElOfClozeHidden = (cloze) => {
      while (!cloze.classList.contains("cloze")) {
        cloze = cloze.parentElement;
      }
      return cloze;
    }

    const revealNextClozeOf = (type) => {
      const nextHidden = document.querySelector(".cloze-hidden")
      if(!nextHidden) {
          return
      } 
      const cloze = clozeElOfClozeHidden(nextHidden);
      if (type === "word") {
          revealClozeWord(cloze)
      } else if (type === "cloze") {
          revealCloze(cloze)
      } else {
        console.error("Invalid type: " + type)
      }
    }

    window.revealNextCloze = function() {
      revealNextClozeOf(revealNextClozeMode)
    }

    /**
     * Return `true` whitespace exists and setEnd() was called, otherwise `false`
     */
    const setRangeEndToBeforeFirstSpace = function(range, node) {
      if (node.nodeType === Node.TEXT_NODE) {
        const match = node.textContent.match(/\s/)
        if (match) {
          range.setEnd(node, match.index);
          return true;
        } else {
          return false;
        }
      } else {
        for (const child of node.childNodes) {
          if (setRangeEndToBeforeFirstSpace(range, child)) {
            return true;
          }
        }
        return false;
      }
    }

    const setRangeEndToAfterLastSpace = function(range, node) {
      if (node.nodeType === Node.TEXT_NODE) {
        const match = node.textContent.match(/\S/)
        if (match) {
          range.setEnd(node, match.index);
          return true;
        } else {
          return false;
        }
      } else {
        for (const child of node.childNodes) {
          if (setRangeEndToAfterLastSpace(range, child)) {
            return true;
          }
        }
        return false;
      }
    }

    const hideAllCloze = function(initial) {
      let clozes = document.getElementsByClassName("cloze")
      let count = 0 // hidden cloze count
      for (const cloze of clozes) {
        const existingHidden = cloze.getElementsByClassName("cloze-hidden")[0]
        if (existingHidden) {
          revealCloze(cloze);
        }
        if (cloze.offsetWidth === 0) {
          continue
        }
        const clozeReplacer = document.createElement("span")
        const clozeHidden = document.createElement("span")
        clozeReplacer.classList.add("cloze-replacer")
        clozeHidden.classList.add("cloze-hidden")
        clozeReplacer.innerHTML = clozeHider(cloze)
        while (cloze.childNodes.length > 0) {
          clozeHidden.appendChild(cloze.childNodes[0])
        }
        cloze.appendChild(clozeReplacer)
        cloze.appendChild(clozeHidden)

        if (window.clozeHints && window.clozeHints[count]) {
          clozeReplacer.classList.add("cloze-hint")
          clozeReplacer.innerHTML = window.clozeHints[count]
        }
        count += 1
        if (initial) {
          cloze.addEventListener("touchend", revealClozeClicked)
          cloze.addEventListener("click", revealClozeClicked)
        }
      }
    }

    window.toggleAllCloze = function() {
      let elems = document.querySelectorAll(".cloze-hidden")
      if(elems.length > 0) {
        for (const elem of elems) {
          const cloze = clozeElOfClozeHidden(elem)
          revealCloze(cloze)
        }
      } else {
        hideAllCloze(initial=false)
      }
    }

    const revealClozeClicked = function(ev) {
      let elem = ev.currentTarget
      if (!ev.altKey && (revealNextClozeMode !== "word")) {
        revealCloze(elem)
      } else {
        revealClozeWord(elem)
      }
      ev.stopPropagation()
      ev.preventDefault()
    }      

    hideAllCloze(initial=true)

    let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)
    let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)
    let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)
    ankingAddEventListener("keydown", (ev) => {
      let next = isShowNextShortcut(ev)
      let word = isShowWordShortcut(ev)
      let all = isToggleAllShortcut(ev)
      if (next) {
        revealNextClozeOf("cloze")
      } else if (word) {
        revealNextClozeOf("word")
      } else if (all) {
        toggleAllCloze()
      } else {
        return;
      }
      ev.stopPropagation()
      ev.preventDefault()
    });
  })()
</script>